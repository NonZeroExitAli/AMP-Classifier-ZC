<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPIC-AMP</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <!-- jspdf library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- jspdf-autotable plugin - THIS IS THE CRITICAL ADDITION -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.14/jspdf.plugin.autotable.min.js"></script>

    <style>
         :root {
            --primary-color: #004d40; /* Dark Teal */
            --secondary-color: #00897b; /* Teal */
            --success-color: #4caf50; /* Green */
            --warning-color: #ff9800; /* Orange */
            --info-color: #2196f3; /* Blue */
            --background-color: #f0f4c3; /* Light Lime */
            --text-color: #333; /* Dark Gray */
            --container-bg-color: #ffffff; /* White */
            --border-color: #bdbdbd; /* Light Gray */
            --button-hover-bg: #00695c; /* Darker Teal */
            --clear-button-bg: #f44336; /* Red */
            --clear-button-hover-bg: #d32f2f; /* Darker Red */
            --analyze-button-bg: #00897b; /* Teal */
            --analyze-button-hover-bg: #00695c; /* Darker Teal */
        }

/* Optional Dark Mode */
    .dark-mode {
        --primary-color: #b2dfdb;    /* Light Teal */
        --secondary-color: #4db6ac;  /* Medium Teal */
        --success-color: #81c784;    /* Light Green */
        --warning-color: #ffcc80;   /* Light Orange */
        --info-color: #90caf9;     /* Light Blue */
        --background-color: #212121; /* Dark Gray */
        --text-color: #eee;         /* Light Gray */
        --container-bg-color: #424242;/* Darker Gray */
        --border-color: #616161;    /* Medium Gray */
        --button-hover-bg: #004d40;  /* Dark Teal */
        --clear-button-bg: #e57373;  /* Light Red */
        --clear-button-hover-bg: #f44336; /* Red */
        --analyze-button-bg: #4db6ac;  /* Medium Teal */
        --analyze-button-hover-bg: #009688; /* Teal */
    }

    body {
        font-family: 'Arial', sans-serif;
        line-height: 1.6;
        margin: 0;
        padding: 20px;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center; /* Centers the main container horizontally */
        background-color: var(--background-color);
        color: var(--text-color);
        transition: background-color 0.3s ease, color 0.3s ease;
    }

    .container {
        max-width: 800px;
        width: 100%;
        padding: 2rem;
        background: var(--container-bg-color);
        border-radius: 10px;
        box-shadow: 0 2px 15px rgba(0,0,0,0.1);
        text-align: center;
        transition: background-color 0.3s ease;
        display: flex;
        flex-direction: column;
        margin-bottom: 20px; /* Space between container and full-width footer */
    }

    .input-group {
        margin-bottom: 1.5rem;
        position: relative;
    }

    #sequence {
        width: 100%;
        height: 150px;
        padding: 1rem;
        border: 2px solid var(--border-color);
        border-radius: 8px;
        font-family: monospace;
        font-size: 1rem;
        resize: vertical;
        transition: border-color 0.3s ease, background-color 0.3s ease;
        background-color: var(--container-bg-color);
        color: var(--text-color);
    }

    #file-input {
        margin-bottom: 1rem;
    }

    #sequence:focus {
        outline: none;
        border-color: var(--secondary-color);
    }

    button {
        color: white;
        border: none;
        padding: 0.8rem 2rem;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1rem;
        transition: transform 0.2s ease, background-color 0.3s ease;
        margin-top: 1rem;
    }
      .button-group button{
       margin: 0 0.2rem;
    }

    button:hover {
        transform: translateY(-1px);
    }

    #clear-btn {
        background-color: var(--clear-button-bg);
    }

    #clear-btn:hover {
        background-color: var(--clear-button-hover-bg);
    }

    #predict-btn {
        background-color: var(--analyze-button-bg);
    }

    #predict-btn:hover {
        background-color: var(--analyze-button-hover-bg);
    }


    .character-count {
        text-align: right;
        color: var(--text-color); /* Use text color */
        font-size: 0.9rem;
        margin-top: 0.5rem;
    }


    .error-message {
         color: var(--warning-color);  /* Use warning color for errors */
        text-align: center;
        margin-top: 1rem;
        display: none;
    }


    .result { /* This might be redundant due to specific result-box styles */
        margin-top: 1.5rem;
        font-size: 1.2rem;
        font-weight: bold;
        color: var(--primary-color);
        text-align: center;
    }

    .info-icon {
        position: absolute;
        top: 1rem;
        right: 1rem;
        font-size: 1.2rem;
        color: var(--info-color);
        cursor: pointer;
    }

    .tooltip {
        position: absolute;
        top: 100%;
        right: 0;
        background-color: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 0.5rem;
        border-radius: 5px;
        display: none;
        z-index: 10;
        width: 250px;
        text-align: left;
        font-size: 0.9rem;
        line-height: 1.4;
    }

    .info-icon:hover + .tooltip,
    .tooltip:hover {
        display: block;
    }

    .progress-container {
         width: 100%;
        height: 8px;
        background-color: var(--border-color); /* Use border color */
        border-radius: 4px;
        margin-top: 1rem;
        overflow: hidden;
        display: none;
    }


    .progress-bar {
        height: 100%;
        width: 0;
        background-color: var(--success-color);
        transition: width: 0.3s ease;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .result.show {
        animation: fadeIn 0.5s ease forwards;
    }

    .confidence-container { /* This block is likely unused now */
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 0.5rem;
    }


    .hidden {
        display: none;
    }


   .tabs {
        display: flex;
        justify-content: center;
        margin-bottom: 1rem;
        border-bottom: 2px solid var(--border-color);
    }

    .tab {
        padding: 0.5rem 1rem;
        margin: 0 0.5rem;
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 5px 5px 0 0;
        background-color: transparent;
        color: var(--text-color);
        transition: border-color 0.3s ease, background-color 0.3s ease;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

   .tab.active {
        border-color: var(--primary-color); /* Use primary color */
        background-color: var(--primary-color); /* Use primary color */
        color: white;
    }

    .tab-content {
        display: none;
        padding: 1rem;
        text-align: left;
    }

    .tab-content.active {
        display: block;
    }

    .metrics-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 1rem;
         box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* Add a subtle shadow */
    }


    .metrics-table th, .metrics-table td {
        padding: 0.5rem;
        border: 1px solid var(--border-color);
        text-align: center;
    }

   .metrics-table th {
        background-color: var(--primary-color); /* Consistent header color */
        color: white;
        font-weight: bold;
        text-transform: uppercase; /* Make headers uppercase */
        letter-spacing: 0.05em; /* Add some letter spacing */
    }

    .metrics-table td {
        padding: 0.8rem 0.5rem; /* Slightly more vertical padding */
    }

    .metrics-table tr:nth-child(even) {
        background-color: #f9f9f9; /* Alternate row background */
    }
    .dark-mode .metrics-table tr:nth-child(even) {
        background-color: #555; /* Dark mode alternate row color */
    }

    .logos-container {
        display: flex;
        justify-content: center;
        align-items: center;
        margin-bottom: 1rem;
        width: 100%;
    }
    .logos-container img {

        transform: scale(1.083); /* Adjust the scale as needed */
        max-width: 100%;  /* Ensure the logo doesn't exceed its container */
        height: auto;     /* Maintain aspect ratio */
    }

    /* Footer Styles - REFINED */
    footer {
        width: 100%;
        padding: 20px; /* Internal padding */
        background-color: var(--container-bg-color);
        border-top: 1px solid var(--border-color);
        font-size: 0.9rem;
        color: var(--text-color);
        text-align: center;
        box-sizing: border-box; /* Include padding in the width calculation */
        /* To span full viewport width while body has padding */
        position: relative;
        left: 0;
        right: 0;
        margin: 0; /* Remove default margins */
        /* These calculations offset the body's horizontal padding */
        width: 100vw;
        margin-left: calc(-100vw / 2 + 50%); 
        margin-right: calc(-100vw / 2 + 50%);
        /* Explicitly define text flow */
        white-space: normal;
        overflow-wrap: break-word; /* For longer words */
    }
    footer p, footer address {
         margin: 0.5rem 0; /* Space for content elements within footer */
         white-space: normal; /* Ensure default text wrapping */
         overflow-wrap: break-word; /* Breaks long words if necessary */
    }


    .button-group {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
    }

    #download-link {
      color: var(--secondary-color);
      text-decoration: none; /* Remove underline */
      font-weight: bold;
      display: block; /* Make it a block element to control margins easier */
      margin: 10px auto; /* Center it within its parent */
      text-align: center; /* For text itself */
    }
    #download-link:hover{
        text-decoration: underline;
    }
    .tab-content h2 {
      color: var(--primary-color);
      margin-bottom: 0.5rem;
      border-bottom: 2px solid var(--secondary-color);
      padding-bottom: 0.25rem;
      display: inline-block; /* Keep the border tight to the text */
    }

    .tab-content h3 {
      color: var(--secondary-color);
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
    }
    .tab-content ul {
        list-style: disc;  /* Use disc bullets */
        margin-left: 20px; /* Indent the list */
        padding-left: 0;   /* Remove default padding */
    }

    .tab-content li {
        margin-bottom: 0.25rem; /* Spacing between list items */
    }
    .tab-content p {
      margin-bottom: 1rem; /* Add some space below paragraphs */
      line-height: 1.7;  /* Increase line height for readability */
    }

    /* Style for SHAP Plot Container */
    #shap-plot-container {
        width: 100%;
        min-height: 300px;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        margin-top: 1rem;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow-x: auto;
    }
     #shap-plot-container img{
        max-width: 100%;
        height: auto;
        display: block;
    }

    /* New styles for result boxes and MIC checkboxes */
    .results-display-group {
        display: grid;
        grid-template-columns: 1fr 1fr; /* Two columns for AMP and Additional Details */
        gap: 1rem;
        margin-top: 2rem;
    }

    .result-box {
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: var(--container-bg-color);
        box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        overflow: hidden;
        color: var(--text-color);
    }

    .dark-mode .result-box {
        background-color: #424242; /* Darker Gray */
        border-color: #616161;
    }


    .result-header {
        background-color: var(--primary-color);
        color: white;
        padding: 0.7rem 1rem;
        font-weight: bold;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 0.8rem;
    }

    .result-content {
        padding: 1rem;
        min-height: 50px; /* Ensure consistent height */
        display: flex;
        flex-direction: column;
        justify-content: center;
        text-align: left; /* Align text to the left within content */
    }
    /* Styles within result-content when dynamically added */
    .result-content p.info-message {
        text-align: center; /* Center the default messages */
        margin-bottom: 0;
        margin-top: 0;
    }
    .result-content ul {
        margin: 0.5rem 0 0 1.5rem; /* Adjust margin for lists */
        padding: 0;
        list-style: disc;
    }
    .result-content ul li {
        margin-bottom: 0.25rem;
    }
    .result-content h4 {
        color: var(--secondary-color);
        margin-top: 0.5rem;
        margin-bottom: 0.5rem;
    }

    /* SHAP Interpretation scrollable section */
    .scrollable-content {
        max-height: 400px; /* Adjust as needed */
        overflow-y: auto;
        padding: 1rem;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        margin-top: 1rem;
        background-color: var(--background-color); /* Matches body or container BG */
    }
    .dark-mode .scrollable-content {
        background-color: #333; /* Darker for dark mode */
        border-color: #616161;
    }
    .scrollable-content h4 {
        color: var(--secondary-color); /* Maintain header color */
        margin-top: 1rem;
        margin-bottom: 0.5rem;
    }


    /* Adjusted MIC checkboxes for appearance */
    .mic-checkbox-group {
        margin-top: 1.5rem;
        padding: 1rem;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        background-color: var(--container-bg-color);
        box-shadow: 0 1px 5px rgba(0,0,0,0.05);
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 15px;
        margin-bottom: 1.5rem;
    }

    .dark-mode .mic-checkbox-group {
        background-color: #424242;
        border-color: #616161;
    }

    .mic-checkbox-container {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 1rem;
        color: var(--text-color);
        user-select: none; /* Prevent text selection */
    }

    .mic-checkbox-container input[type="checkbox"] {
        appearance: none;
        -webkit-appearance: none;
        width: 20px;
        height: 20px;
        border: 2px solid var(--primary-color);
        border-radius: 4px;
        margin-right: 8px;
        cursor: pointer;
        position: relative;
        outline: none;
        transition: all 0.2s ease-in-out;
    }

    .mic-checkbox-container input[type="checkbox"]:checked {
        background-color: var(--primary-color);
        border-color: var(--primary-color);
    }

    .mic-checkbox-container input[type="checkbox"]:checked::before {
        content: '\2713'; /* Checkmark unicode */
        display: block;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 14px;
        color: white;
    }

    .mic-checkbox-container .mic-label {
        margin-left: 5px;
        font-weight: normal;
    }

    /* Small screen adjustments for responsive footer */
    @media (max-width: 768px) {
        body {
            padding: 10px; /* Less padding on smaller screens */
        }
        footer {
            /* On very small screens, 100vw might cause horizontal scroll if body has padding */
            /* Re-adjust these if using the advanced 100vw negative margin method with body padding */
            padding-left: 10px; /* Reset padding to be consistent with body for this breakpoint */
            padding-right: 10px;
            /* Recalculate margins for 100vw/50% relative to a padded body */
            margin-left: calc(-50vw + 50%); /* Use 50% relative to viewport *current effective body width */
            margin-right: calc(-50vw + 50%); /* This helps if body has static padding */
        }
    }


</style>

</head>
<body>

<div class="container">
    <div class="logos-container">
        <img src="image.png" alt="Tool Logo">
    </div>

    <div class="tabs">
        <div class="tab active" data-tab="prediction">
            <i class="fas fa-search"></i> Prediction
        </div>
        <div class="tab" data-tab="model">
            <i class="fas fa-chart-line"></i> Models' Metrics & Sample run
        </div>
        <div class="tab" data-tab="about">
            <i class="fas fa-info-circle"></i> About
        </div>
         <div class="tab" data-tab="usage">
            <i class="fas fa-book"></i> Usage Guide
        </div>
    </div>

    <div class="tab-content active" id="prediction">
       <h2>AMP & MIC Predictor</h2>
        <p>Enter an amino acid sequence (between 10 and 100 valid amino acids) or upload a FASTA file to predict AMP class and MIC values.</p>
        <div class="input-group">
            <input type="file" id="file-input" accept=".fasta,.fa,.fna">
            <textarea id="sequence" placeholder="Enter amino acid sequence (10-100 Valid AAs) or upload a FASTA file..." maxlength="100"></textarea>
            <div class="character-count">
                <span id="char-count">0</span>/100
            </div>
            <i class="info-icon" id="info-icon">ⓘ</i>
            <div class="tooltip">
                Enter the amino acid sequence you want to classify or upload a FASTA file. The sequence must be between 10 and 100 characters long and contain only standard amino acid characters (ACDEFGHIKLMNPQRSTVWY).
            </div>
        </div>

        <h3 style="margin-top: 0rem; margin-bottom: 0.5rem;">Select Bacteria for MIC Prediction</h3>
        <p style="margin-top: 0; margin-bottom: 1rem;">Choose one or more bacteria for which you'd like to predict the Minimum Inhibitory Concentration (MIC) of the peptide. MIC prediction is only performed if the sequence is classified as an Antimicrobial Peptide (AMP).</p>

        <div class="mic-checkbox-group">
            <label class="mic-checkbox-container">
                <input type="checkbox" id="mic-ecoli" value="e_coli" disabled>
                <span class="mic-label">E.coli</span>
            </label>
            <label class="mic-checkbox-container">
                <input type="checkbox" id="mic-paeruginosa" value="p_aeruginosa" disabled>
                <span class="mic-label">P. aeruginosa</span>
            </label>
            <label class="mic-checkbox-container">
                <input type="checkbox" id="mic-saureus" value="s_aureus" disabled>
                <span class="mic-label">S. aureus</span>
            </label>
            <label class="mic-checkbox-container">
                <input type="checkbox" id="mic-kpneumoniae" value="k_pneumoniae" disabled>
                <span class="mic-label">K. pneumoniae</span>
            </label>
        </div>

        <div class="button-group">
            <button onclick="clearInput()" id="clear-btn">Clear Input</button>
            <button onclick="classifySequenceDebounced()" id="predict-btn">Submit</button>
        </div>

        <div class="error-message" id="error"></div>

        <div class="progress-container" id="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>

        <div class="results-display-group">
            <div class="result-box">
                <div class="result-header"><i class="fas fa-file-alt"></i>Classification</div>
                <div class="result-content" id="amp-classification-output">
                    <p class="info-message"></p>
                </div>
            </div>

            <div class="result-box">
                <div class="result-header"><i class="fas fa-info-circle"></i> Additional Details</div>
                <div class="result-content" id="additional-details-output">
                    <p class="info-message">The detailed report will appear here.</p>
                    <a id="download-link" style="display: none;">Download Detailed Report (PDF)</a> <!-- MOVED HERE, inline style display:none initially -->
                </div>
            </div>
        </div>
    </div>

    <div class="tab-content" id="model">
        <h2>Classifier Metrics</h2>
        <p>The following table presents the performance metrics of our antimicrobial peptide classification model. These metrics were obtained on a held-out test set, separate from the training data.</p>
        <table class="metrics-table">
            <thead>
                <tr>
                    <th>Metric</th>
                    <th>Value</th>
                    <th>Description</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Accuracy</td>
                    <td>0.963</td>
                    <td>The overall correctness of the model, representing the proportion of correctly classified sequences (both AMP and Non-AMP).</td>
                </tr>
                <tr>
                    <td>Precision</td>
                    <td>0.964</td>
                    <td>Out of all sequences predicted as AMPs, the proportion that are truly AMPs.  A high precision indicates fewer false positives.</td>
                </tr>
                <tr>
                    <td>Recall</td>
                    <td>0.963</td>
                    <td>Out of all actual AMP sequences, the proportion that the model correctly identifies. A high recall indicates fewer false negatives.</td>
                </tr>
                <tr>
                    <td>F1-Score</td>
                    <td>0.963</td>
                    <td>The harmonic mean of precision and recall, providing a balanced measure of the model's performance.</td>
                </tr>
                <tr>
                    <td>Validation Accuracy</td>
                    <td>0.968</td>
                    <td>The accuracy of the model on a separate validation dataset, used during model development to tune hyperparameters.</td>
                </tr>
            </tbody>
        </table>

        <!-- Start of regressor metrics -->
        <h2 style="margin-top: 2rem;">Regressor Metrics (MIC Prediction Models)</h2>
        <p>The Minimum Inhibitory Concentration (MIC) prediction is handled by separate regressor models. Their performance metrics for each bacterium are detailed below:</p>

        <table class="metrics-table">
            <thead>
                <tr>
                    <th>Bacterium</th>
                    <th>MSE (log)</th>
                    <th>MSE</th>
                    <th>R2</th>
                    <th>MAE</th>
                    <th>Pearson</th>
                    <th>Kendall</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>E.coli</td>
                    <td>0.0481</td>
                    <td>0.4864</td>
                    <td>0.7023</td>
                    <td>0.1375</td>
                    <td>0.8394</td>
                    <td>0.6725</td>
                </tr>
                <tr>
                    <td>P. aeruginosa</td>
                    <td>0.0517</td>
                    <td>0.5227</td>
                    <td>0.6864</td>
                    <td>0.1233</td>
                    <td>0.8311</td>
                    <td>0.6922</td>
                </tr>
                 <tr>
                    <td>S.aureus</td>
                    <td>0.0517</td>
                    <td>0.4988</td>
                    <td>0.6828</td>
                    <td>0.1472</td>
                    <td>0.8278</td>
                    <td>0.6536</td>
                </tr>
                <tr>
                    <td>K. pneumoniae</td>
                    <td>0.0538</td>
                    <td>0.4292</td>
                    <td>0.7416</td>
                    <td>0.1479</td>
                    <td>0.8693</td>
                    <td>0.7194</td>
                </tr>
            </tbody>
        </table>
        <!-- End of regressor metrics -->


        <h2 style="margin-top: 2rem;">Model Interpretability</h2>
        <p>To understand how our model makes predictions, we use SHAP (SHapley Additive exPlanations) values. SHAP values help to explain the output of the model by assessing the contribution of each feature to the prediction.</p>

        <h3>SHAP Plot</h3>
        <p>The SHAP plot below visualizes the features that most significantly influence the model's prediction. Positive SHAP values contribute to the sequence being classified as AMP, while negative values contribute to Non-AMP classification.</p>

        <div id="shap-plot-container">
            <img src="shap.png" alt="SHAP Plot" >
        </div>

        <h3>Interpretation of SHAP Plot</h3>
        <!-- Start of scrollable section for SHAP Interpretation -->
        <div class="scrollable-content">
             <p>Based on the SHAP plot, the model's predictions for Antimicrobial Peptides (AMPs) are influenced by a combination of sequence-based, structural, and biophysical features. Here’s a breakdown of the key features and their biological implications:</p>

            <h4>A. Sequence-Based Features</h4>
            <h5>APAAC13 & APAAC5 (Amphiphilic Pseudo-Amino Acid Composition)</h5>
            <ul>
                <li><strong>Description:</strong> These features encode hydrophobicity, charge, and side-chain properties, reflecting the amphiphilic nature of the peptide.</li>
                <li><strong>Interpretation:</strong> Higher APAAC values have a positive SHAP impact, indicating they are predictive of AMP activity. This suggests that the model values amphiphilic sequences, which are crucial for disrupting bacterial membranes.</li>
            </ul>

            <h5>Amino Acid Composition (M, C)</h5>
            <ul>
                <li><strong>M (Methionine):</strong>
                    <ul>
                        <li><strong>Description:</strong> Methionine is often associated with structural stability in peptides.</li>
                        <li><strong>Interpretation:</strong>  The plot suggests Methionine content has a positive influence, possibly contributing to the stability of AMP candidates.</li>
                    </ul>
                </li>
                <li><strong>C (Cysteine):</strong>
                    <ul>
                        <li><strong>Description:</strong> Cysteine is known for forming disulfide bonds, which can stabilize AMP structures like defensins.</li>
                        <li><strong>Interpretation:</strong> High cysteine content appears to have a positive SHAP impact. This could be because disulfide-stabilized AMPs often exhibit enhanced antimicrobial action.</li>
                    </ul>
                </li>
            </ul>

            <h4>B. Structural and Biophysical Features</h4>
            <ul>
                <li><strong>HydrophobicityD3001:</strong>
                    <ul>
                        <li><strong>Description:</strong> Represents the overall hydrophobicity of the peptide sequence.</li>
                        <li><strong>Interpretation:</strong> Hydrophobicity is shown to be a critical feature. More hydrophobic peptides are strongly favored for AMP classification, aligning with the understanding that hydrophobicity is essential for membrane insertion and disruption.</li>
                    </ul>
                </li>
                <li><strong>PolarityD1001:</strong>
                    <ul>
                        <li><strong>Description:</b>  Measures the polarity of the peptide sequence.</li>
                        <li><strong>Interpretation:</strong>  The model considers polarity, likely in balance with hydrophobicity. An optimal AMP efficacy is often linked to having both hydrophobic and polar residues to facilitate membrane interaction and solubility.</li>
                    </ul>
                </li>
                <li><strong>Solvent Accessibility (SolventAccessibilityD3001):</strong>
                    <ul>
                        <li><strong>Description:</strong> Reflects how exposed the residues are to the solvent (water).</li>
                        <li><strong>Interpretation:</strong> Solvent-accessible residues positively contribute to AMP prediction. This might indicate that exposed residues facilitate interaction with bacterial membranes or the surrounding environment.</li>
                    </ul>
                </li>
                <li><strong>Charge (ChargeD2001):</b>
                    <ul>
                        <li><strong>Description:</strong> Represents the net charge of the peptide.</li>
                        <li><strong>Interpretation:</strong> Charge is a significant positive predictor. Most AMPs are cationic, enabling them to interact with negatively charged bacterial membranes. Higher charge, as indicated by positive SHAP values, typically enhances antimicrobial potency.</li>
                    </ul>
                </li>
                <li><strong>PolarizabilityD3001 & NormalizedVDWVD3001:</strong>
                    <ul>
                        <li><strong>Description:</strong> These features relate to electronic distribution (Polarizability) and steric effects (NormalizedVDWVD) of the peptide.</li>
                        <li><strong>Interpretation:</strong> These properties impact membrane penetration and peptide-membrane interactions. Their positive SHAP values suggest they are important for AMP activity, possibly by influencing how the peptide inserts into and destabilizes membranes.</li>
                    </ul>
                </li>
            </ul>

            <h4>C. Geary Autocorrelation Features</h4>
            <p>Geary autocorrelation descriptors reflect spatial properties of peptides, encoding information about the adhesion and distribution of physicochemical properties along the sequence.</p>
            <ul>
                <li><strong>GearyAuto_Hydrophobicity30:</strong>
                    <ul>
                        <li><strong>Description:</strong> Encodes the clustering of hydrophobic residues within a spatial lag of 30.</li>
                        <li><strong>Interpretation:</strong> Higher values of hydrophobicity autocorrelation are positively associated with AMP prediction. This likely reflects the importance of hydrophobic clustering in forming amphipathic structures, such as α-helices, which are common and effective in AMPs.</li>
                    </ul>
                </li>
                <li><strong>GearyAuto_Steric30 & GearyAuto_Steric29:</strong>
                    <ul>
                        <li><strong>Description:</strong> Reflect peptide backbone flexibility and steric properties at spatial lags of 30 and 29.</li>
                        <li><strong>Interpretation:</strong>  These features have a positive SHAP impact, suggesting that a certain degree of peptide backbone flexibility may be beneficial for AMP action. Flexibility could enhance the peptide's ability to interact with and adapt to diverse bacterial membrane structures.</li>
                    </ul>
                </li>
                <li><strong>GearyAuto_ResidueASA30:</strong>
                    <ul>
                        <li><strong>Description:</strong> Indicates the autocorrelation of accessible surface area of residues at a spatial lag of 30.</li>
                        <li><strong>Interpretation:</strong> Higher autocorrelation of residue accessible surface area is favored. This could mean that a consistent pattern of residue exposure, possibly with higher exposure of charged or polar residues, improves bacterial targeting or membrane interaction.</li>
                    </ul>
                </li>
            </ul>
        </div>
        <!-- End of scrollable section for SHAP Interpretation -->

        <h3>Sample Run</h3>
         <p>You can test the model with various sequences to understand its behavior.  Here are a few examples:</p>
        <ul>
            <li><strong>Test 1:</strong> Long Sequence of 99 AAs (P-AMP) - MEKAALIFIGLLLFSTCTQILAQSCNNDSDCTNLKCATKNIKCEQNKCQCLDERYIRA
                ISLNTRSPRCNVQSCIDHCKAIGEVIYVCFTYHCYCRKPPM</li>
            <li><strong>Test 2:</strong> Long Sequence of 99 AAs (Non-AMP) - MKSLLPLAILAALAVAALCYESHESMESYEVSPFTTRRNANTFISPQQRWHAK
                AQERVRELNKPAQEINREACDDYKLCERYALIYGYNAAYNRYFRQR</li>
            <li><strong>Test 3:</strong> Short Sequence of 51 AAs (P-AMP) - SLQGGAPNFPQPSQQNGGWQVSPDLGRDDKGNTRGQIEIQNKGKDHDFNAG</li>
            <li><strong>Test 4:</strong> Short Sequence of 50 AAs (Non-AMP) - MKPLKQKVSITLDEDVIKNLKTLAEECDRSLSQYINLILKEHLKNLDQQ</li>
            <li><strong>Test 5:</strong> Invalid Characters (eg. X) - MEKAALIFIGLLLFSTCTQILAQSC(XX).</li>

        </ul>


    </div>

    <div class="tab-content" id="about">
        <h2>About This Tool</h2>
        <p>This web application provides a user-friendly interface for classifying amino acid sequences as either Antimicrobial Peptides (AMPs) or Non-Antimicrobial Peptides (Non-AMPs). AMPs are crucial components of the innate immune system, offering defense against a wide range of pathogens.</p>

        <h3>Model Selection Criteria</h3>
        <p>To identify the most effective model, our team rigorously evaluated over 225 combinations of feature extraction and selection methods across four different machine learning models for each target organism. The evaluation included both classification and regression tasks, with a focus on predicting antimicrobial activity and estimating minimum inhibitory concentration (MIC) values.

The final model was selected based on the following criteria:</p>
        <ul>
            <li><strong>High Accuracy, F1-score, and Validation Accuracy:</b> The model achieved excellent performance metrics on a held-out test set, demonstrating its ability to generalize to unseen data.</li>
            <li><strong>Robustness to Sequence Length Variations:</strong> The model performs consistently well on sequences of varying lengths, within the specified range (10-100 amino acids).</li>
            <li><strong>Generalization Ability:</strong> The model was trained and evaluated on diverse datasets to ensure its ability to classify a broad range of AMP sequences.</li>
            <li><strong>Robust regression capability: Assessed using Mean Squared Error (MSE), R-squared (R²), Pearson correlation, and Kendall’s tau, the model demonstrated strong agreement between predicted and true MIC values.

</li>
        </ul>

        <h3>Intended Use</h3>
        <p>This tool is intended for research and educational purposes. It can be a valuable resource for researchers studying antimicrobial peptides and developing new therapeutic strategies. However, it is not a replacement for laboratory-based experimental validation.</p>

        <h3>Our Team</h3>
        <ul>
            <li>Ali Magdi - Computational Biologist</li>
            <li>Ahmed Amr - Computational Biologist</li>
            <li>Omar Loay - Molecular Biologist</li>
            <li>Prof. Eman Badr - Full Professor and Director of BCBU</li>
        </ul>

        <h3>Acknowledgements</h3>
        <p>We extend our gratitude to the following organizations for their support:</p>
        <ul>
            <li>Bioinformatics and Computational Biology Unit at Zewail City.</li>
            <li>The Centre for Genomics at Zewail City.</li>
        </ul>

        <h3>Contact</h3>
        <p>For questions, inquiries, or feedback, please reach out to us at: <a href="mailto:s-ali.afifi@zewailcity.edu.eg">s-ali.afifi@zewailcity.edu.eg</a></p>
    </div>
     <div class="tab-content" id="usage">
         <h2>Usage Guide</h2>
        <p>Follow these steps to use the AMP Classifier:</p>

        <h3>Step 1: Prepare Your Sequence</h3>
        <ul>
            <li>You can either enter the amino acid sequence directly or upload a FASTA file.</li>
            <li>Ensure your sequence contains only standard amino acid characters (ACDEFGHIKLMNPQRSTVWY).</li>
             <li>The sequence length must be between 10 and 100 amino acids.</li>
        </ul>

        <h3>Step 2: Input the Sequence</h3>
        <ul>
            <li><strong>Direct Input:</strong> Type or paste your sequence into the text area provided.</li>
            <li><strong>FASTA File Upload:</strong> Click the "Choose File" button and select your .fasta, .fa, or .fna file.</li>
            <li>The character count will update as you type or upload a sequence.</li>
        </ul>

        <h3>Step 3: Analyze the Sequence</h3>
        <ul>
            <li>Click the "Submit" button.</li>
            <li>A progress bar will appear, indicating that the analysis is underway.</li>
        </ul>

        <h3>Step 4: View the Results</h3>
        <ul>
            <li>Once the analysis is complete, the prediction (AMP or Non-AMP) will be displayed in the "AMP Classification" box.</li>
            <li>A link to "Download Detailed Report (PDF)" will appear, containing the prediction, confidence, MIC values (if selected and applicable), and a LIME interpretability plot.</li>
        </ul>

        <h3>Step 5: Clear the Input</h3>
        <ul>
             <li>To analyze another sequence, click the "Clear Input" button. This will reset the input fields and results.</li>
        </ul>
         <h3>Troubleshooting</h3>
            <ul>
                <li><strong>Invalid Characters:</strong> If you see an error message about invalid characters, double-check that your sequence contains only standard amino acid characters.</li>
                <li><strong>Sequence Length:</strong> Ensure your sequence is between 10 and 100 characters long.</li>
                 <li><strong>Invalid FASTA Format:</strong> If you encounter an error with a FASTA file, make sure the file is correctly formatted.</li>
            </ul>

    </div>
</div>
<!-- Moved footer OUTSIDE container for full width -->
<footer>
    <p>© 2025, Bioinformatics and Computational biology Unit, BCBU</p>
    <address>
     Bioinformatics and Computational biology Unit at Zewail City,<br>
      Ahmed Zewail Street, October Gardens, Giza,<br>
      Egypt
    </address>
</footer>
<script type="module">
    import { client } from "https://cdn.jsdelivr.net/npm/@gradio/client/+esm";
    window.gradio = { client };
</script>

<script>
    const sequenceInput = document.getElementById('sequence');
    const charCount = document.getElementById('char-count');
    const errorDiv = document.getElementById('error');
    const predictBtn = document.getElementById('predict-btn');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const fileInput = document.getElementById('file-input');
    const downloadLink = document.getElementById('download-link'); // Now directly points to the element inside additional-details-output

    // Result display elements
    const ampClassificationOutput = document.getElementById('amp-classification-output');
    const additionalDetailsOutput = document.getElementById('additional-details-output');
    const micCheckboxes = document.querySelectorAll('.mic-checkbox-group input[type="checkbox"]');

    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(c => c.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById(tab.dataset.tab).classList.add('active');
        });
    });

    let clientInstance;
    let debounceTimer;
    let animationIntervalId;

    async function initClient() {
        try {
            // !!! IMPORTANT: CHOOSE ONE OF THE FOLLOWING LINES AND COMMENT OUT THE OTHER !!!
            // Option 1: If you are running the Gradio backend locally (e.g., python app.py)
            // clientInstance = await window.gradio.client("http://127.0.0.1:7860/");
            // Option 2: If your Gradio backend is deployed on Hugging Face Spaces (using the Space ID)
            clientInstance = await window.gradio.client("nonzeroexit/AMP-Classifier");

        } catch (error) {
            console.error("Failed to initialize Gradio client:", error);
            showError("Failed to connect to the classifier service. Please check your network and the Gradio backend URL, then try again.");
            predictBtn.disabled = true;
        }
    }

    window.onload = function() {
        initClient();
        document.getElementById('info-icon').addEventListener('mouseenter', showTooltip);
        document.getElementById('info-icon').addEventListener('mouseleave', hideTooltip);
        fileInput.addEventListener('change', handleFileSelect);
        clearInput(); // Call clearInput on load to set initial state
    };

    function showTooltip() {
        document.querySelector('.tooltip').style.display = 'block';
    }

    function hideTooltip() {
        document.querySelector('.tooltip').style.display = 'none';
    }

    function clearInput() {
        sequenceInput.value = '';
        fileInput.value = '';
        charCount.textContent = '0';
        clearError();
        
        // Hide download link explicitly using its direct ID as it's now in additionalDetailsOutput
        downloadLink.style.display = 'none';

        ampClassificationOutput.innerHTML = '<p class="info-message">The prediction will appear here.</p>'; // Use info-message class for default styling
        additionalDetailsOutput.innerHTML = '<p class="info-message">The detailed report will appear here.</p>'; // Ensure this clears other content too
        // Append download link back to the output div so it's managed correctly
        additionalDetailsOutput.appendChild(downloadLink);


        micCheckboxes.forEach(checkbox => {
            checkbox.checked = false;
            checkbox.disabled = true;
        });

        if (animationIntervalId) {
            clearInterval(animationIntervalId);
            animationIntervalId = null;
        }
        progressBar.style.width = '0%';
        progressContainer.style.display = 'none';

        predictBtn.disabled = true; // Disable button until valid input
        predictBtn.textContent = 'Submit';
    }

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) {
            clearInput();
            return;
        }

        const allowedExtensions = ['.fasta', '.fa', '.fna'];
        const fileName = file.name.toLowerCase();
        const isValidExtension = allowedExtensions.some(ext => fileName.endsWith(ext));

        if (!isValidExtension) {
            showError('Invalid file type. Please upload a .fasta, .fa, or .fna file.');
            fileInput.value = '';
            micCheckboxes.forEach(checkbox => checkbox.disabled = true);
            predictBtn.disabled = true;
            return;
        }

        clearError();

        const reader = new FileReader();

        reader.onload = function(e) {
            try {
                const sequence = parseFASTA(e.target.result);
                if (sequence) {
                    sequenceInput.value = sequence;
                    updateCharacterCount();
                    validateSequence(sequence);
                } else {
                    showError("No valid sequence found in FASTA file.");
                    fileInput.value = '';
                    micCheckboxes.forEach(checkbox => checkbox.disabled = true);
                    predictBtn.disabled = true;
                }
            } catch (error) {
                console.error("Error in reader.onload:", error);
                showError(error.message);
                fileInput.value = '';
                micCheckboxes.forEach(checkbox => checkbox.disabled = true);
                predictBtn.disabled = true;
            }
        };

        reader.onerror = function(error) {
            console.error("FileReader error:", error);
            showError("Error reading file.");
            fileInput.value = '';
            micCheckboxes.forEach(checkbox => checkbox.disabled = true);
            predictBtn.disabled = true;
        };

        reader.readAsText(file);
    }

    function parseFASTA(text) {
        const lines = text.trim().split(/[\r\n]+/);
        const sequences = [];
        let currentSequence = '';
        let hasHeader = false;

        for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine.startsWith('>')) {
                if (hasHeader && currentSequence) {
                    sequences.push(currentSequence);
                }
                currentSequence = '';
                hasHeader = true;
            } else if (hasHeader && trimmedLine) {
                currentSequence += trimmedLine.replace(/\s/g, '').toUpperCase();
            }
        }

        if (hasHeader && currentSequence) {
            sequences.push(currentSequence);
        }

        if (sequences.length === 0) {
            throw new Error("Invalid FASTA format. No valid sequences found.");
        }
        if (sequences.length > 1) {
            console.warn("Multiple sequences found in FASTA file. Using only the first sequence.");
            return sequences[0];
        } else {
            return sequences[0];
        }
    }

    function validateSequence(sequence) {
        let isValid = true;
        let errorMessage = '';

        if (!sequence) {
            errorMessage = ''; // No error message for empty, just disable button
            isValid = false;
        } else if (/[^ACDEFGHIKLMNPQRSTVWY]/.test(sequence)) {
            errorMessage = 'Invalid characters in sequence. Only standard amino acid characters (ACDEFGHIKLMNPQRSTVWY) are allowed.';
            isValid = false;
        } else if (sequence.length < 10 || sequence.length > 100) {
            errorMessage = `Sequence length (${sequence.length}) must be between 10 and 100 characters.`;
            isValid = false;
        }

        if (isValid) {
            clearError();
            predictBtn.disabled = false;
        } else {
            showError(errorMessage);
            predictBtn.disabled = true;
        }

        micCheckboxes.forEach(checkbox => {
            checkbox.disabled = !isValid;
            if (!isValid) checkbox.checked = false;
        });

        return isValid;
    }

    function updateCharacterCount() {
        charCount.textContent = sequenceInput.value.length;
    }

    sequenceInput.addEventListener('input', () => {
        updateCharacterCount();
        validateSequence(sequenceInput.value);
    });

    sequenceInput.addEventListener('paste', (e) => {
        e.preventDefault();
        const paste = (e.clipboardData || window.clipboardData).getData('text');
        const cleanPaste = paste.replace(/[^ACDEFGHIKLMNPQRSTVWY]/gi, '').toUpperCase();

        const selectionStart = sequenceInput.selectionStart;
        const selectionEnd = sequenceInput.selectionEnd;

        const currentText = sequenceInput.value;
        const newText = currentText.substring(0, selectionStart) + cleanPaste + currentText.substring(selectionEnd);

        sequenceInput.value = newText;
        updateCharacterCount();
        validateSequence(newText);
    });

    sequenceInput.addEventListener('keypress', (e) => {
        if (e.key.length === 1 && !/^[ACDEFGHIKLMNPQRSTVWY]$/i.test(e.key)) {
            e.preventDefault();
            // Optional: show a temporary visual cue for invalid keypress
        } else {
            clearError();
        }
    });

    function showError(message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
    }

    function clearError() {
        errorDiv.style.display = 'none';
    }

    async function classifySequenceDebounced() {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(classifySequence, 300);
    }

    async function classifySequence() {
        const sequence = sequenceInput.value.trim().toUpperCase();

        if (!validateSequence(sequence)) {
            return;
        }

        clearError();
        predictBtn.disabled = true;
        predictBtn.textContent = 'Processing...';

        // Set initial messages for display boxes
        ampClassificationOutput.innerHTML = '<p class="info-message">Analyzing...</p>';
        additionalDetailsOutput.innerHTML = '<p class="info-message">Generating detailed report...</p>';
        // Append download link back to the output div so it's managed correctly
        additionalDetailsOutput.appendChild(downloadLink);
        downloadLink.style.display = 'none'; // Ensure download link is hidden while processing

        micCheckboxes.forEach(checkbox => checkbox.disabled = true); // Disable MIC checkboxes while processing

        progressContainer.style.display = 'block';
        progressBar.style.width = '0%';

        // These variables will store the parsed data for the PDF
        let micDataForPdf = {};
        let ampLabel = 'Unknown';
        let ampConfidence = 0;
        let shapPlotBase64 = null; // Cannot be parsed from the current text output, will remain null for PDF
        let topFeaturesForPdf = []; // Parsed from text

        let animationProgress = 0;
        animationIntervalId = setInterval(() => {
            if (animationProgress < 95) {
                animationProgress += 5;
                progressBar.style.width = `${animationProgress}%`;
            }
        }, 100);

        try {
            // Call the main Gradio API endpoint to get the combined text output
            // Assumes the `/predict` endpoint returns the entire formatted string.
            const classificationResult = await clientInstance.predict("/predict", [sequence]);

            if (!classificationResult || !classificationResult.data || typeof classificationResult.data[0] !== 'string') {
                throw new Error("Unexpected result format from server. Expected a plain text string.");
            }

            const rawTextOutput = classificationResult.data[0];
            console.log("Raw text output from Gradio:", rawTextOutput); // Log raw output for debugging

            // --- Start Text Parsing Logic (Essential for PDF Data) ---
            const lines = rawTextOutput.split('\n').map(line => line.trim()).filter(Boolean); // Split into lines, trim, remove empty

            // Regex patterns
            const labelRegex = /Prediction:\s*(.+)/;
            const confidenceRegex = /Confidence:\s*([\d.]+)%/;
            const micSectionHeader = /Predicted MIC Values \(μM\):/;
            const topFeaturesSectionHeader = /Top Features Influencing Prediction:/;
            const micLineRegex = /-\s*(.+?):\s*([\d.]+)/;
            const featureLineRegex = /-\s*(.+?):\s*([\d.-]+)/;


            // Parse Label and Confidence
            const labelMatch = rawTextOutput.match(labelRegex);
            if (labelMatch && labelMatch[1]) {
                ampLabel = labelMatch[1];
            } else {
                 console.warn("Could not parse AMP Label from output for PDF.");
                 ampLabel = 'Prediction Unavailable';
            }

            const confidenceMatch = rawTextOutput.match(confidenceRegex);
            if (confidenceMatch && confidenceMatch[1]) {
                ampConfidence = parseFloat(confidenceMatch[1]) / 100;
            } else {
                console.warn("Could not parse Confidence from output for PDF.");
                ampConfidence = 0; // Default to 0
            }


            // Parse MIC values and Top Features by section for PDF generation
            let micSectionStarted = false;
            let topFeaturesSectionStarted = false;

            for (const line of lines) {
                if (line.match(micSectionHeader)) {
                    micSectionStarted = true;
                    topFeaturesSectionStarted = false;
                    continue;
                } else if (line.match(topFeaturesSectionHeader)) {
                    topFeaturesSectionStarted = true;
                    micSectionStarted = false;
                    continue;
                }

                if (micSectionStarted && !topFeaturesSectionStarted) {
                    const micLineMatch = line.match(micLineRegex);
                    if (micLineMatch && micLineMatch[1] && micLineMatch[2]) {
                        const bacteriumNameMap = {
                            'E.coli': 'e_coli',
                            'P.aeruginosa': 'p_aeruginosa',
                            'S.aureus': 's_aureus',
                            'K.Pneumonia': 'k_pneumoniae', // Ensure this matches your sample if it's 'K.Pneumonia'
                        };
                        const displayMicName = micLineMatch[1].trim();
                        const internalKey = bacteriumNameMap[displayMicName];

                        // ONLY add MIC to micDataForPdf if its checkbox was CHECKED
                        const isMicCheckboxChecked = Array.from(micCheckboxes).some(
                            cb => cb.checked && cb.value === internalKey
                        );

                        if (internalKey && isMicCheckboxChecked) {
                             micDataForPdf[internalKey] = parseFloat(micLineMatch[2]);
                        } else if (internalKey && !isMicCheckboxChecked) {
                            console.log(`MIC for ${displayMicName} was parsed but not selected by user for PDF.`);
                        } else {
                            console.warn("Unknown MIC bacterium key in raw output text:", displayMicName);
                        }
                    }
                } else if (topFeaturesSectionStarted) {
                    const featureLineMatch = line.match(featureLineRegex);
                    if (featureLineMatch && featureLineMatch[1] && featureLineMatch[2]) {
                        const fullFeatureDesc = featureLineMatch[1].trim();
                        const value = parseFloat(featureLineMatch[2]);

                        let featureName = fullFeatureDesc;
                        let condition = '';
                        const complexFeatureRegex = /(.*)\s*(<=|>=|<|>)\s*([\d.]+)$/;
                        const complexMatch = fullFeatureDesc.match(complexFeatureRegex);
                        if (complexMatch) {
                            featureName = complexMatch[1].trim();
                            condition = `${complexMatch[2]} ${complexMatch[3]}`;
                        }

                        topFeaturesForPdf.push({
                            feature: featureName,
                            condition: condition,
                            value: value
                        });
                    }
                }
            }
            // --- End Text Parsing Logic ---


            clearInterval(animationIntervalId);
            animationIntervalId = null;
            progressBar.style.width = '100%';
            progressContainer.style.display = 'none';

            // --- Update ON-SCREEN Display ---

            // AMP Classification Output: Only the label
            ampClassificationOutput.innerHTML = `
                <p style="font-size: 1.3rem; font-weight: bold; color: ${ampLabel.includes('Non-AMP') ? 'var(--clear-button-bg)' : 'var(--success-color)'}; margin: 0; text-align: center;">${ampLabel}</p>
            `;

            // Additional Details Output: Only the download link and a message
            additionalDetailsOutput.innerHTML = '<p class="info-message">Detailed report available for download:</p>';
            additionalDetailsOutput.appendChild(downloadLink); // Append the actual link element
            downloadLink.style.display = 'block'; // Make the link visible


            // Re-enable/disable MIC checkboxes based on AMP prediction
            // This is primarily for new submissions, as parsed MIC values dictate PDF.
            if (ampLabel.includes('AMP (Positive)')) {
                micCheckboxes.forEach(checkbox => checkbox.disabled = false);
            } else {
                micCheckboxes.forEach(checkbox => {
                    checkbox.checked = false;
                    checkbox.disabled = true;
                });
            }

            // Generate and provide PDF report (PDF will use the parsed micDataForPdf)
            generatePDFReport(sequence, ampLabel, ampConfidence, micDataForPdf, topFeaturesForPdf, shapPlotBase64);


        } catch (error) {
            console.error("Error during prediction:", error);
            if (animationIntervalId) {
                clearInterval(animationIntervalId);
                animationIntervalId = null;
            }
            progressBar.style.width = '0%';
            progressContainer.style.display = 'none';

            showError("Prediction failed: " + (error.message || "Unknown error"));
            ampClassificationOutput.innerHTML = '<p style="text-align: center; color: var(--clear-button-bg);">Error</p>';
            additionalDetailsOutput.innerHTML = '<p style="text-align: center; color: var(--clear-button-bg);">Error during prediction. Detailed report not available.</p>';
            additionalDetailsOutput.appendChild(downloadLink); // Ensure link is still in DOM even on error
            downloadLink.style.display = 'none'; // Keep hidden on error
        } finally {
            predictBtn.disabled = false;
            predictBtn.textContent = 'Submit';
        }
    }

    // Function to generate the PDF report using jspdf and jspdf-autotable
    function generatePDFReport(sequence, prediction, confidence, micResults = null, topFeatures = null, shapPlotBase64 = null) {
        if (!window.jspdf || !window.jspdf.jsPDF) {
            console.error("jsPDF is not loaded correctly.");
            return;
        }
        // This confirms jspdf is loaded correctly.
        const pdf = new window.jspdf.jsPDF(); // Correct way to instantiate jsPDF with plugins

        // Set up standard colors and fonts
        const primaryColor = [0, 77, 64]; // Dark Teal
        const textColor = [51, 51, 51]; // Dark Gray
        const successColor = [39, 174, 96]; // Emerald Green
        const errorColor = [231, 76, 60]; // Alizarin Red


        pdf.setFont("helvetica"); // Default font family for report
        pdf.setFontSize(22);
        pdf.setTextColor(44, 62, 80); // Dark Blue-Gray for title
        pdf.text("AMP Classification & MIC Report", 105, 20, { align: "center" });

        // Add logo if available
        const imgElement = document.querySelector('.logos-container img');
        if (imgElement && imgElement.src) {
            const imgData = getBase64Image(imgElement);
            if (imgData) {
                pdf.addImage(imgData, 'PNG', 25, 22, 30, 15);
            }
        }

        let yPos = 55; // Initial Y position for content

        // Input Sequence
        pdf.setFontSize(16);
        pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2]);
        pdf.text("Input Sequence:", 20, yPos);
        pdf.setFontSize(12);
        pdf.setTextColor(textColor[0], textColor[1], textColor[2]);
        const maxWidth = 170;
        const sequenceLines = pdf.splitTextToSize(sequence, maxWidth);
        pdf.text(sequenceLines, 20, yPos + 10);
        yPos += 10 + (sequenceLines.length * pdf.getLineHeight()) + 10;

        // AMP Classification
        pdf.setFontSize(16);
        pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2]);
        pdf.text("AMP Classification:", 20, yPos);
        pdf.setFontSize(14);
        if (prediction.includes('(Non-AMP)')) {
             pdf.setTextColor(errorColor[0], errorColor[1], errorColor[2]);
         } else {
            pdf.setTextColor(successColor[0], successColor[1], successColor[2]);
         }
        pdf.text(prediction, 20, yPos + 10);
        yPos += 20;

        // Confidence
        pdf.setFontSize(16);
        pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2]);
        pdf.text("Confidence:", 20, yPos);
        pdf.setFontSize(14);
        pdf.setTextColor(successColor[0], successColor[1], successColor[2]);
        pdf.text(`${(confidence * 100).toFixed(2)}%`, 20, yPos + 10);
        yPos += 20;


        // MIC Values Table
        if (micResults && Object.keys(micResults).length > 0) {
            if (yPos + 40 > pdf.internal.pageSize.height - 30) { // Check for page break needed
                pdf.addPage();
                yPos = 20; // Reset Y for new page
            }
            pdf.setFontSize(16);
            pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2]);
            pdf.text("Predicted MIC (µM):", 20, yPos);
            yPos += 10;

            const micTableHead = [['Bacterium', 'MIC (µM)']];
            const micTableBody = [];
            const bacteriumDisplayNamesForPdf = { // Using consistent display names
                'e_coli': 'E.coli',
                'p_aeruginosa': 'P. aeruginosa',
                's_aureus': 'S.aureus',
                'k_pneumoniae': 'K.Pneumoniae', // Consistent with sample format
            };

            for (const bacteriumKey in micResults) {
                if (typeof micResults[bacteriumKey] === 'number' && bacteriumDisplayNamesForPdf[bacteriumKey]) {
                    micTableBody.push([
                        bacteriumDisplayNamesForPdf[bacteriumKey],
                        micResults[bacteriumKey].toFixed(3)
                    ]);
                }
            }
            
            pdf.autoTable({
                startY: yPos,
                head: micTableHead,
                body: micTableBody,
                theme: 'striped',
                headStyles: {
                    fillColor: primaryColor, // Dark Teal header
                    textColor: 255 // White text
                },
                styles: {
                    cellPadding: 3,
                    fontSize: 10,
                    textColor: textColor,
                    lineColor: [200, 200, 200], // Lighter border
                    lineWidth: 0.1
                },
                columnStyles: {
                    0: { fontStyle: 'italic' }, // Italicize bacterium name column (jspdf-autotable applies it correctly to cells)
                },
                didDrawPage: function(data) { // Handler for pagination (new page starts)
                    yPos = data.cursor.y; // Update yPos after table draws
                }
            });
            yPos = pdf.lastAutoTable.finalY + 10; // Update Y position based on table end
        } else {
            pdf.setFontSize(12);
            pdf.setTextColor(100, 100, 100);
            pdf.text("No MIC predictions were selected or generated for this peptide.", 20, yPos + 10);
            yPos += 20;
        }


        // Top Features Influencing Prediction Table
        if (topFeatures && topFeatures.length > 0) {
            if (yPos + 40 > pdf.internal.pageSize.height - 30) { // Check for page break needed
                pdf.addPage();
                yPos = 20; // Reset Y for new page
            }
            pdf.setFontSize(16);
            pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2]);
            pdf.text("Top Features Influencing Prediction:", 20, yPos);
            yPos += 10;

            const featuresTableHead = [['Feature', 'Condition', 'SHAP Value']];
            const featuresTableBody = topFeatures.map(f => {
                // Ensure feature name is consistent, convert null/undefined condition to empty string for display
                return [f.feature || '', f.condition || '', (typeof f.value === 'number' ? f.value.toFixed(4) : '')];
            });

            pdf.autoTable({
                startY: yPos,
                head: featuresTableHead,
                body: featuresTableBody,
                theme: 'striped',
                headStyles: {
                    fillColor: primaryColor,
                    textColor: 255
                },
                styles: {
                    cellPadding: 3,
                    fontSize: 10,
                    textColor: textColor,
                    lineColor: [200, 200, 200],
                    lineWidth: 0.1
                },
                columnStyles: { // Adjust column widths if needed, these are examples
                    0: { cellWidth: 60 },
                    1: { cellWidth: 60, halign: 'center' },
                    2: { cellWidth: 50, halign: 'right' }
                },
                didDrawPage: function(data) {
                    yPos = data.cursor.y;
                }
            });
            yPos = pdf.lastAutoTable.finalY + 10;
        } else {
            pdf.setFontSize(12);
            pdf.setTextColor(100, 100, 100);
            pdf.text("No specific features provided for this prediction.", 20, yPos + 10);
            yPos += 20;
        }

        // SHAP Plot (still from base64 if present, or static image for interpretation context)
        // Note: For current setup, shapPlotBase64 will be null as it's not in the raw text output from Gradio.
        if (shapPlotBase64) {
            if (yPos + 80 > pdf.internal.pageSize.height - 30) { // Approx space for image
                pdf.addPage();
                yPos = 20;
            }
            pdf.setFontSize(16);
            pdf.setTextColor(primaryColor[0], primaryColor[1], primaryColor[2]);
            pdf.text("SHAP Interpretability Plot:", 20, yPos);
            yPos += 10;

            const imgWidth = 160; // Max width to fit page
            const imgHeight = 90; // Approx height for plot

            try {
                const dataURL = `data:image/png;base64,${shapPlotBase64}`;
                pdf.addImage(dataURL, 'PNG', 20, yPos, imgWidth, imgHeight);
                yPos += imgHeight + 10;
            } catch (imgError) {
                console.error("Error adding SHAP plot to PDF:", imgError);
                pdf.setFontSize(12);
                pdf.setTextColor(100, 100, 100);
                pdf.text("SHAP plot could not be embedded.", 20, yPos);
                yPos += 10;
            }
        } else {
            // This message indicates no dynamic SHAP plot was received
            if (yPos + 10 < pdf.internal.pageSize.height - 30) {
                pdf.setFontSize(12);
                pdf.setTextColor(100, 100, 100);
                yPos += 20;
            }
        }

        // Footer
        pdf.setFontSize(10);
        pdf.setTextColor(127, 140, 141);
        pdf.text("Generated by BCBU-ZC AMP Classifier", 105, pdf.internal.pageSize.height - 15, { align: "center" });

        const pdfBlob = pdf.output('blob');
        const pdfUrl = URL.createObjectURL(pdfBlob);

        downloadLink.href = pdfUrl;
        downloadLink.download = `AMP_Classifier_Report_${new Date().toISOString().slice(0, 10)}.pdf`;
    }

    function getBase64Image(img) {
        if (!img || !img.src) {
            console.error("Image element not found or has no source.");
            return null;
        }
        try {
            // Check if the image is loaded, if not, wait for it or handle gracefully
            if (!img.complete || img.naturalWidth === 0 || img.naturalHeight === 0) {
                 console.warn("Image not fully loaded or invalid dimensions for base64 conversion. Ensure image is loaded.");
                 return null;
            }

            const canvas = document.createElement("canvas");
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const dataURL = canvas.toDataURL("image/png");
            return dataURL;
        } catch (error) {
            console.error("Error converting image to base64:", error);
            return null;
        }
    }

</script>

</body>
</html>
